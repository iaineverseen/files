local Passes, Fails, Undefined = 0, 0, 0
local Results = {}

local function GetGlobal(Path)
	local Value = getgenv and getgenv() or getfenv(2)
	while Value ~= nil and Path ~= "" do
		local Name, NextPath = string.match(Path, "^([^.]+)%.?(.*)$")
		Value = Value[Name]
		Path = NextPath
	end
	return Value
end

local function Log(Msg)
	table.insert(Results, Msg)
end

local TestQueue = {}

local function Test(Name, Aliases, Callback, Target)
	table.insert(TestQueue, {
		Name = Name,
		Aliases = Aliases,
		Callback = Callback
	})
end

Test("cache.invalidate", {}, function()
	local Container = Instance.new("Folder")
	local Part = Instance.new("Part", Container)
	cache.invalidate(Container:FindFirstChild("Part"))
	assert(Part ~= Container:FindFirstChild("Part"), "Reference `part` could not be invalidated")
end)

Test("cache.iscached", {}, function()
	local Part = Instance.new("Part")
	assert(cache.iscached(Part), "Part should be cached")
	cache.invalidate(Part)
	assert(not cache.iscached(Part), "Part should not be cached")
end)

Test("cache.replace", {}, function()
	local Part = Instance.new("Part")
	local Fire = Instance.new("Fire")
	cache.replace(Part, Fire)
	assert(Part ~= Fire, "Part was not replaced with Fire")
end)

Test("cloneref", {}, function()
	local Part = Instance.new("Part")
	local Clone = cloneref(Part)
	assert(Part ~= Clone, "Clone should not be equal to original")
	Clone.Name = "Test"
	assert(Part.Name == "Test", "Clone should have updated the original")
end)

Test("compareinstances", {}, function()
	local Part = Instance.new("Part")
	local Clone = cloneref(Part)
	assert(Part ~= Clone, "Clone should not be equal to original")
	assert(compareinstances(Part, Clone), "Clone should be equal to original when using compareinstances()")
end)

local function ShallowEqual(T1, T2)
	if T1 == T2 then return true end
	local UniqueTypes = { ["function"] = true, ["table"] = true, ["userdata"] = true, ["thread"] = true }
	for K, V in pairs(T1) do
		if UniqueTypes[type(V)] then
			if type(T2[K]) ~= type(V) then return false end
		elseif T2[K] ~= V then return false end
	end
	for K, V in pairs(T2) do
		if UniqueTypes[type(V)] then
			if type(T2[K]) ~= type(V) then return false end
		elseif T1[K] ~= V then return false end
	end
	return true
end

Test("checkcaller", {}, function()
	assert(checkcaller(), "Main scope should return true")
end)

Test("clonefunction", {}, function()
	local function Test() return "success" end
	local Copy = clonefunction(Test)
	assert(Test() == Copy(), "The clone should return the same value as the original")
	assert(Test ~= Copy, "The clone should not be equal to the original")
end)

Test("getcallingscript", {})

Test("getscriptclosure", {"getscriptfunction"}, function()
	local Module = game:GetService("CoreGui").RobloxGui.Modules.Common.Constants
	local Constants = getrenv().require(Module)
	local Generated = getscriptclosure(Module)()
	assert(Constants ~= Generated, "Generated module should not match the original")
	assert(ShallowEqual(Constants, Generated), "Generated constant table should be shallow equal to the original")
end)

Test("hookfunction", {"replaceclosure"}, function()
	local function Test() return true end
	local Ref = hookfunction(Test, function() return false end)
	assert(Test() == false, "Function should return false")
	assert(Ref() == true, "Original function should return true")
	assert(Test ~= Ref, "Original function should not be same as the reference")
end)

Test("iscclosure", {}, function()
	assert(iscclosure(print) == true, "Function 'print' should be a C closure")
	assert(iscclosure(function() end) == false, "Executor function should not be a C closure")
end)

Test("islclosure", {}, function()
	assert(islclosure(print) == false, "Function 'print' should not be a Lua closure")
	assert(islclosure(function() end) == true, "Executor function should be a Lua closure")
end)

Test("isexecutorclosure", {"checkclosure", "isourclosure"}, function()
	assert(isexecutorclosure(isexecutorclosure) == true, "Did not return true for an executor global")
	assert(isexecutorclosure(newcclosure(function() end)) == true, "Did not return true for an executor C closure")
	assert(isexecutorclosure(function() end) == true, "Did not return true for an executor Luau closure")
	assert(isexecutorclosure(print) == false, "Did not return false for a Roblox global")
end)

Test("loadstring", {}, function()
	local Animate = game:GetService("Players").LocalPlayer.Character.Animate
	local Bytecode = getscriptbytecode(Animate)
	local Func = loadstring(Bytecode)
	assert(type(Func) ~= "function", "Luau bytecode should not be loadable!")
	assert(assert(loadstring("return ... + 1"))(1) == 2, "Failed to do simple math")
	assert(type(select(2, loadstring("f"))) == "string", "Loadstring did not return anything for a compiler error")
end)

Test("newcclosure", {}, function()
	local function Test() return true end
	local TestC = newcclosure(Test)
	assert(Test() == TestC(), "New C closure should return the same value as the original")
	assert(Test ~= TestC, "New C closure should not be same as the original")
	assert(iscclosure(TestC), "New C closure should be a C closure")
end)

Test("rconsoleclear", {"consoleclear"})
Test("rconsolecreate", {"consolecreate"})
Test("rconsoledestroy", {"consoledestroy"})
Test("rconsoleinput", {"consoleinput"})
Test("rconsoleprint", {"consoleprint"})
Test("rconsolesettitle", {"rconsolename", "consolesettitle"})

Test("crypt.base64encode", {"crypt.base64.encode", "crypt.base64_encode", "base64.encode", "base64_encode"}, function()
	assert(crypt.base64encode("test") == "dGVzdA==", "Base64 encoding failed")
end)

Test("crypt.base64decode", {"crypt.base64.decode", "crypt.base64_decode", "base64.decode", "base64_decode"}, function()
	assert(crypt.base64decode("dGVzdA==") == "test", "Base64 decoding failed")
end)

Test("crypt.encrypt", {}, function()
	local Key = crypt.generatekey()
	local Encrypted, Iv = crypt.encrypt("test", Key, nil, "CBC")
	assert(Iv, "crypt.encrypt should return an IV")
	local Decrypted = crypt.decrypt(Encrypted, Key, Iv, "CBC")
	assert(Decrypted == "test", "Failed to decrypt raw string from encrypted data")
end)

Test("crypt.decrypt", {}, function()
	local Key, Iv = crypt.generatekey(), crypt.generatekey()
	local Encrypted = crypt.encrypt("test", Key, Iv, "CBC")
	local Decrypted = crypt.decrypt(Encrypted, Key, Iv, "CBC")
	assert(Decrypted == "test", "Failed to decrypt raw string from encrypted data")
end)

Test("crypt.generatebytes", {}, function()
	local Size = math.random(10, 100)
	local Bytes = crypt.generatebytes(Size)
	assert(#crypt.base64decode(Bytes) == Size, "The decoded result should be " .. Size .. " bytes long")
end)

Test("crypt.generatekey", {}, function()
	local Key = crypt.generatekey()
	assert(#crypt.base64decode(Key) == 32, "Generated key should be 32 bytes long when decoded")
end)

Test("crypt.hash", {}, function()
	local Algorithms = {'sha1', 'sha384', 'sha512', 'md5', 'sha256', 'sha3-224', 'sha3-256', 'sha3-512'}
	for _, Algorithm in ipairs(Algorithms) do
		local Hash = crypt.hash("test", Algorithm)
		assert(Hash, "crypt.hash on algorithm '" .. Algorithm .. "' should return a hash")
	end
end)

Test("debug.getconstant", {}, function()
	local function Test() print("Hello, world!") end
	assert(debug.getconstant(Test, 1) == "print", "First constant must be print")
	assert(debug.getconstant(Test, 2) == nil, "Second constant must be nil")
	assert(debug.getconstant(Test, 3) == "Hello, world!", "Third constant must be 'Hello, world!'")
end)

Test("debug.getconstants", {}, function()
	local function Test()
		local Num = 5000 .. 50000
		print("Hello, world!", Num, warn)
	end
	local Constants = debug.getconstants(Test)
	assert(Constants[1] == 50000, "First constant must be 50000")
	assert(Constants[2] == "print", "Second constant must be print")
	assert(Constants[3] == nil, "Third constant must be nil")
	assert(Constants[4] == "Hello, world!", "Fourth constant must be 'Hello, world!'")
	assert(Constants[5] == "warn", "Fifth constant must be warn")
end)

Test("debug.getinfo", {}, function()
	local Types = {
		source = "string", short_src = "string", func = "function", what = "string",
		currentline = "number", name = "string", nups = "number", numparams = "number",
		is_vararg = "number"
	}
	local function Test(...) print(...) end
	local Info = debug.getinfo(Test)
	for K, V in pairs(Types) do
		assert(Info[K] ~= nil, "Did not return a table with a '" .. K .. "' field")
		assert(type(Info[K]) == V, "Did not return a table with " .. K .. " as a " .. V)
	end
end)

Test("debug.getproto", {}, function()
	local function Test()
		local function Proto() return true end
	end
	local Proto = debug.getproto(Test, 1, true)[1]
	local RealProto = debug.getproto(Test, 1)
	assert(Proto, "Failed to get the inner function")
	assert(Proto() == true, "The inner function did not return anything")
	if not RealProto() then return "Proto return values are disabled on this executor" end
end)

Test("debug.getprotos", {}, function()
	local function Test()
		local function _1() return true end
		local function _2() return true end
		local function _3() return true end
	end
	for I in ipairs(debug.getprotos(Test)) do
		local Proto = debug.getproto(Test, I, true)[1]
		local RealProto = debug.getproto(Test, I)
		assert(Proto(), "Failed to get inner function " .. I)
		if not RealProto() then return "Proto return values are disabled on this executor" end
	end
end)

Test("debug.getstack", {}, function()
	local _ = "a" .. "b"
	assert(debug.getstack(1, 1) == "ab", "The first item in the stack should be 'ab'")
	assert(debug.getstack(1)[1] == "ab", "The first item in the stack table should be 'ab'")
end)

Test("debug.getupvalue", {}, function()
	local Upvalue = function() end
	local function Test() print(Upvalue) end
	assert(debug.getupvalue(Test, 1) == Upvalue, "Unexpected value returned from debug.getupvalue")
end)

Test("debug.getupvalues", {}, function()
	local Upvalue = function() end
	local function Test() print(Upvalue) end
	local Upvalues = debug.getupvalues(Test)
	assert(Upvalues[1] == Upvalue, "Unexpected value returned from debug.getupvalues")
end)

Test("debug.setconstant", {}, function()
	local function Test() return "fail" end
	debug.setconstant(Test, 1, "success")
	assert(Test() == "success", "debug.setconstant did not set the first constant")
end)

Test("debug.setstack", {}, function()
	local function Test() return "fail", debug.setstack(1, 1, "success") end
	assert(Test() == "success", "debug.setstack did not set the first stack item")
end)

Test("debug.setupvalue", {}, function()
	local function Upvalue() return "fail" end
	local function Test() return Upvalue() end
	debug.setupvalue(Test, 1, function() return "success" end)
	assert(Test() == "success", "debug.setupvalue did not set the first upvalue")
end)

if isfolder and makefolder and delfolder then
	if isfolder(".tests") then delfolder(".tests") end
	makefolder(".tests")
end

Test("readfile", {}, function()
	writefile(".tests/readfile.txt", "success")
	assert(readfile(".tests/readfile.txt") == "success", "Did not return the contents of the file")
end)

Test("listfiles", {}, function()
	makefolder(".tests/listfiles")
	writefile(".tests/listfiles/test_1.txt", "success")
	writefile(".tests/listfiles/test_2.txt", "success")
	local Files = listfiles(".tests/listfiles")
	assert(#Files == 2, "Did not return the correct number of files")
	assert(isfile(Files[1]), "Did not return a file path")
	assert(readfile(Files[1]) == "success", "Did not return the correct files")
	makefolder(".tests/listfiles_2")
	makefolder(".tests/listfiles_2/test_1")
	makefolder(".tests/listfiles_2/test_2")
	local Folders = listfiles(".tests/listfiles_2")
	assert(#Folders == 2, "Did not return the correct number of folders")
	assert(isfolder(Folders[1]), "Did not return a folder path")
end)

Test("writefile", {}, function()
	writefile(".tests/writefile.txt", "success")
	assert(readfile(".tests/writefile.txt") == "success", "Did not write the file")
	local RequiresFileExt = pcall(function()
		writefile(".tests/writefile", "success")
		assert(isfile(".tests/writefile.txt"))
	end)
	if not RequiresFileExt then return "This executor requires a file extension in writefile" end
end)

Test("makefolder", {}, function()
	makefolder(".tests/makefolder")
	assert(isfolder(".tests/makefolder"), "Did not create the folder")
end)

Test("appendfile", {}, function()
	writefile(".tests/appendfile.txt", "su")
	appendfile(".tests/appendfile.txt", "cce")
	appendfile(".tests/appendfile.txt", "ss")
	assert(readfile(".tests/appendfile.txt") == "success", "Did not append the file")
end)

Test("isfile", {}, function()
	writefile(".tests/isfile.txt", "success")
	assert(isfile(".tests/isfile.txt") == true, "Did not return true for a file")
	assert(isfile(".tests") == false, "Did not return false for a folder")
	assert(isfile(".tests/doesnotexist.exe") == false, "Did not return false for a nonexistent path")
end)

Test("isfolder", {}, function()
	assert(isfolder(".tests") == true, "Did not return false for a folder")
	assert(isfolder(".tests/doesnotexist.exe") == false, "Did not return false for a nonexistent path")
end)

Test("delfolder", {}, function()
	makefolder(".tests/delfolder")
	delfolder(".tests/delfolder")
	assert(isfolder(".tests/delfolder") == false, "Failed to delete folder")
end)

Test("delfile", {}, function()
	writefile(".tests/delfile.txt", "Hello, world!")
	delfile(".tests/delfile.txt")
	assert(isfile(".tests/delfile.txt") == false, "Failed to delete file")
end)

Test("dofile", {})

Test("isrbxactive", {"isgameactive"}, function()
	assert(type(isrbxactive()) == "boolean", "Did not return a boolean value")
end)

Test("mouse1click", {})
Test("mouse1press", {})
Test("mouse1release", {})
Test("mouse2click", {})
Test("mouse2press", {})
Test("mouse2release", {})
Test("mousemoveabs", {})
Test("mousemoverel", {})
Test("mousescroll", {})

Test("fireclickdetector", {}, function()
	local Detector = Instance.new("ClickDetector")
	fireclickdetector(Detector, 50, "MouseHoverEnter")
end)

Test("getcallbackvalue", {}, function()
	local Bindable = Instance.new("BindableFunction")
	local function Test() end
	Bindable.OnInvoke = Test
	assert(getcallbackvalue(Bindable, "OnInvoke") == Test, "Did not return the correct value")
end)

Test("getconnections", {}, function()
	local Types = {
		Enabled = "boolean", ForeignState = "boolean", LuaConnection = "boolean",
		Function = "function", Thread = "thread", Fire = "function", Defer = "function",
		Disconnect = "function", Disable = "function", Enable = "function"
	}
	local Bindable = Instance.new("BindableEvent")
	Bindable.Event:Connect(function() end)
	local Connection = getconnections(Bindable.Event)[1]
	for K, V in pairs(Types) do
		assert(Connection[K] ~= nil, "Did not return a table with a '" .. K .. "' field")
		assert(type(Connection[K]) == V, "Did not return a table with " .. K .. " as a " .. V)
	end
end)

Test("getcustomasset", {}, function()
	writefile(".tests/getcustomasset.txt", "success")
	local ContentId = getcustomasset(".tests/getcustomasset.txt")
	assert(type(ContentId) == "string", "Did not return a string")
	assert(#ContentId > 0, "Returned an empty string")
	assert(string.match(ContentId, "rbxasset://") == "rbxasset://", "Did not return an rbxasset url")
end)

Test("gethiddenproperty", {}, function()
	local Fire = Instance.new("Fire")
	local Property, IsHidden = gethiddenproperty(Fire, "size_xml")
	assert(Property == 5, "Did not return the correct value")
	assert(IsHidden == true, "Did not return whether the property was hidden")
end)

Test("sethiddenproperty", {}, function()
	local Fire = Instance.new("Fire")
	local Hidden = sethiddenproperty(Fire, "size_xml", 10)
	assert(Hidden, "Did not return true for the hidden property")
	assert(gethiddenproperty(Fire, "size_xml") == 10, "Did not set the hidden property")
end)

Test("gethui", {}, function()
	assert(typeof(gethui()) == "Instance", "Did not return an Instance")
end)

Test("getinstances", {}, function()
	assert(getinstances()[1]:IsA("Instance"), "The first value is not an Instance")
end)

Test("getnilinstances", {}, function()
	assert(getnilinstances()[1]:IsA("Instance"), "The first value is not an Instance")
	assert(getnilinstances()[1].Parent == nil, "The first value is not parented to nil")
end)

Test("isscriptable", {}, function()
	local Fire = Instance.new("Fire")
	assert(isscriptable(Fire, "size_xml") == false, "Did not return false for a non-scriptable property")
	assert(isscriptable(Fire, "Size") == true, "Did not return true for a scriptable property")
end)

Test("setscriptable", {}, function()
	local Fire = Instance.new("Fire")
	local WasScriptable = setscriptable(Fire, "size_xml", true)
	assert(WasScriptable == false, "Did not return false for a non-scriptable property")
	assert(isscriptable(Fire, "size_xml") == true, "Did not set the scriptable property")
	Fire = Instance.new("Fire")
	assert(isscriptable(Fire, "size_xml") == false, "⚠️⚠️ setscriptable persists between unique instances ⚠️⚠️")
end)

Test("setrbxclipboard", {})

Test("getrawmetatable", {}, function()
	local Metatable = { __metatable = "Locked!" }
	local Object = setmetatable({}, Metatable)
	assert(getrawmetatable(Object) == Metatable, "Did not return the metatable")
end)

Test("hookmetamethod", {}, function()
	local Object = setmetatable({}, { __index = newcclosure(function() return false end), __metatable = "Locked!" })
	local Ref = hookmetamethod(Object, "__index", function() return true end)
	assert(Object.test == true, "Failed to hook a metamethod and change the return value")
	assert(Ref() == false, "Did not return the original function")
end)

Test("getnamecallmethod", {}, function()
	local Method
	local Ref
	Ref = hookmetamethod(game, "__namecall", function(...)
		if not Method then Method = getnamecallmethod() end
		return Ref(...)
	end)
	game:GetService("Lighting")
	assert(Method == "GetService", "Did not get the correct method (GetService)")
end)

Test("isreadonly", {}, function()
	local Object = {}
	table.freeze(Object)
	assert(isreadonly(Object), "Did not return true for a read-only table")
end)

Test("setrawmetatable", {}, function()
	local Object = setmetatable({}, { __index = function() return false end, __metatable = "Locked!" })
	local ObjectReturned = setrawmetatable(Object, { __index = function() return true end })
	assert(Object, "Did not return the original object")
	assert(Object.test == true, "Failed to change the metatable")
	if ObjectReturned then
		return ObjectReturned == Object and "Returned the original object" or "Did not return the original object"
	end
end)

Test("setreadonly", {}, function()
	local Object = { success = false }
	table.freeze(Object)
	setreadonly(Object, false)
	Object.success = true
	assert(Object.success, "Did not allow the table to be modified")
end)

Test("identifyexecutor", {"getexecutorname"}, function()
	local Name, Version = identifyexecutor()
	assert(type(Name) == "string", "Did not return a string for the name")
	return type(Version) == "string" and "Returns version as a string" or "Does not return version"
end)

Test("lz4compress", {}, function()
	local Raw = "Hello, world!"
	local Compressed = lz4compress(Raw)
	assert(type(Compressed) == "string", "Compression did not return a string")
	assert(lz4decompress(Compressed, #Raw) == Raw, "Decompression did not return the original string")
end)

Test("lz4decompress", {}, function()
	local Raw = "Hello, world!"
	local Compressed = lz4compress(Raw)
	assert(type(Compressed) == "string", "Compression did not return a string")
	assert(lz4decompress(Compressed, #Raw) == Raw, "Decompression did not return the original string")
end)

Test("messagebox", {})
Test("queue_on_teleport", {"queueonteleport"})

Test("request", {"http.request", "http_request"}, function()
	local Response = request({
		Url = "https://httpbin.org/user-agent",
		Method = "GET",
	})
	assert(type(Response) == "table", "Response must be a table")
	assert(Response.StatusCode == 200, "Did not return a 200 status code")
	local Data = game:GetService("HttpService"):JSONDecode(Response.Body)
	assert(type(Data) == "table" and type(Data["user-agent"]) == "string", "Did not return a table with a user-agent key")
	return "User-Agent: " .. Data["user-agent"]
end)

Test("setclipboard", {"toclipboard"})

Test("setfpscap", {}, function()
	local RenderStepped = game:GetService("RunService").RenderStepped
	local function Step()
		RenderStepped:Wait()
		local Sum = 0
		for _ = 1, 5 do Sum = Sum + 1 / RenderStepped:Wait() end
		return math.round(Sum / 5)
	end
	setfpscap(60)
	local Step60 = Step()
	setfpscap(0)
	local Step0 = Step()
	return Step60 .. "fps @60 • " .. Step0 .. "fps @0"
end)

Test("getgc", {}, function()
	local Gc = getgc()
	assert(type(Gc) == "table", "Did not return a table")
	assert(#Gc > 0, "Did not return a table with any values")
end)

Test("getgenv", {}, function()
	getgenv().__TEST_GLOBAL = true
	assert(__TEST_GLOBAL, "Failed to set a global variable")
	getgenv().__TEST_GLOBAL = nil
end)

Test("getloadedmodules", {}, function()
	local Modules = getloadedmodules()
	assert(type(Modules) == "table", "Did not return a table")
	assert(#Modules > 0, "Did not return a table with any values")
	assert(typeof(Modules[1]) == "Instance", "First value is not an Instance")
	assert(Modules[1]:IsA("ModuleScript"), "First value is not a ModuleScript")
end)

Test("getrenv", {}, function()
	assert(_G ~= getrenv()._G, "The variable _G in the executor is identical to _G in the game")
end)

Test("getrunningscripts", {}, function()
	local Scripts = getrunningscripts()
	assert(type(Scripts) == "table", "Did not return a table")
	assert(#Scripts > 0, "Did not return a table with any values")
	assert(typeof(Scripts[1]) == "Instance", "First value is not an Instance")
	assert(Scripts[1]:IsA("ModuleScript") or Scripts[1]:IsA("LocalScript"), "First value is not a ModuleScript or LocalScript")
end)

Test("getscriptbytecode", {"dumpstring"}, function()
	local Animate = game:GetService("Players").LocalPlayer.Character.Animate
	local Bytecode = getscriptbytecode(Animate)
	assert(type(Bytecode) == "string", "Did not return a string for Character.Animate")
end)

Test("getscripthash", {}, function()
	local Animate = game:GetService("Players").LocalPlayer.Character.Animate:Clone()
	local Hash = getscripthash(Animate)
	local Source = Animate.Source
	Animate.Source = "print('Hello, world!')"
	task.defer(function() Animate.Source = Source end)
	local NewHash = getscripthash(Animate)
	assert(Hash ~= NewHash, "Did not return a different hash for a modified script")
	assert(NewHash == getscripthash(Animate), "Did not return the same hash for a script with the same source")
end)

Test("getscripts", {}, function()
	local Scripts = getscripts()
	assert(type(Scripts) == "table", "Did not return a table")
	assert(#Scripts > 0, "Did not return a table with any values")
	assert(typeof(Scripts[1]) == "Instance", "First value is not an Instance")
	assert(Scripts[1]:IsA("ModuleScript") or Scripts[1]:IsA("LocalScript"), "First value is not a ModuleScript or LocalScript")
end)

Test("getsenv", {}, function()
	local Animate = game:GetService("Players").LocalPlayer.Character.Animate
	local Env = getsenv(Animate)
	assert(type(Env) == "table", "Did not return a table for Character.Animate")
	assert(Env.script == Animate, "The script global is not identical to Character.Animate")
end)

Test("getthreadidentity", {"getidentity", "getthreadcontext"}, function()
	assert(type(getthreadidentity()) == "number", "Did not return a number")
end)

Test("setthreadidentity", {"setidentity", "setthreadcontext"}, function()
	setthreadidentity(3)
	assert(getthreadidentity() == 3, "Did not set the thread identity")
end)

Test("Drawing", {})
Test("Drawing.new", {}, function()
	local Drawing = Drawing.new("Square")
	Drawing.Visible = false
	local CanDestroy = pcall(function() Drawing:Destroy() end)
	assert(CanDestroy, "Drawing:Destroy() should not throw an error")
end)

Test("Drawing.Fonts", {}, function()
	assert(Drawing.Fonts.UI == 0, "Did not return the correct id for UI")
	assert(Drawing.Fonts.System == 1, "Did not return the correct id for System")
	assert(Drawing.Fonts.Plex == 2, "Did not return the correct id for Plex")
	assert(Drawing.Fonts.Monospace == 3, "Did not return the correct id for Monospace")
end)

Test("isrenderobj", {}, function()
	local Drawing = Drawing.new("Image")
	Drawing.Visible = true
	assert(isrenderobj(Drawing) == true, "Did not return true for an Image")
	assert(isrenderobj(newproxy()) == false, "Did not return false for a blank table")
end)

Test("getrenderproperty", {}, function()
	local Drawing = Drawing.new("Image")
	Drawing.Visible = true
	assert(type(getrenderproperty(Drawing, "Visible")) == "boolean", "Did not return a boolean value for Image.Visible")
	local Success, Result = pcall(function() return getrenderproperty(Drawing, "Color") end)
	if not Success or not Result then return "Image.Color is not supported" end
end)

Test("setrenderproperty", {}, function()
	local Drawing = Drawing.new("Square")
	Drawing.Visible = true
	setrenderproperty(Drawing, "Visible", false)
	assert(Drawing.Visible == false, "Did not set the value for Square.Visible")
end)

Test("cleardrawcache", {}, function() cleardrawcache() end)

Test("WebSocket", {})
Test("WebSocket.connect", {}, function()
	local Types = {
		Send = "function", Close = "function",
		OnMessage = {"table", "userdata"}, OnClose = {"table", "userdata"}
	}
	local Ws = WebSocket.connect("ws://echo.websocket.events")
	assert(type(Ws) == "table" or type(Ws) == "userdata", "Did not return a table or userdata")
	for K, V in pairs(Types) do
		if type(V) == "table" then
			assert(table.find(V, type(Ws[K])), "Did not return a " .. table.concat(V, ", ") .. " for " .. K)
		else
			assert(type(Ws[K]) == V, "Did not return a " .. V .. " for " .. K)
		end
	end
	Ws:Close()
end)

print("\nUNC Environment Check")
print("⏺️ - No test, ⛔ - Fail, ⚠️ - Missing aliases\n")

local function RunTestsSequential()
	for I, T in ipairs(TestQueue) do
		if I % 5 == 0 then task.wait() end
		local Name = T.Name
		local Aliases = T.Aliases
		local Callback = T.Callback
		if not Callback then
			Log("⏺️ " .. Name)
		elseif not GetGlobal(Name) then
			Fails = Fails + 1
			Log("⛔ " .. Name)
		else
			local Success, Message = pcall(Callback)
			Name = tostring(Name)
			Message = tostring(Message)
			if Success then
				Passes = Passes + 1
				Log("✅ " .. Name .. ((Message ~= "nil") and (" • " .. Message) or ""))
			else
				Fails = Fails + 1
				Log("⛔ " .. Name .. " failed: " .. Message)
			end
		end
		local UndefinedAliases = {}
		for _, Alias in ipairs(Aliases) do
			if GetGlobal(Alias) == nil then table.insert(UndefinedAliases, Alias) end
		end
		if #UndefinedAliases > 0 then
			Undefined = Undefined + 1
			Log("⚠️ " .. table.concat(UndefinedAliases, ", "))
		end
	end
end

RunTestsSequential()

print("\n----- RESULTS -----\n")
for _, Msg in ipairs(Results) do
	print(Msg)
	task.wait()
end

print("\nUNC Summary (white cat was here :3)")
local Rate = math.round(Passes / (Passes + Fails) * 100)
local OutOf = Passes .. " out of " .. (Passes + Fails)
print("✅ Tested with a " .. Rate .. "% success rate (" .. OutOf .. ")")
print("⛔ " .. Fails .. " tests failed")
print("⚠️ " .. Undefined .. " globals are missing aliases")